<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../iron-selector/iron-selectable.html">

<!--
`<iron-swipeable-pages>` manages a set of pages and and provides the ability to switch
between them by swiping gesture.

Example:

    <iron-swipeable-pages selected="0">
      <div>One</div>
      <div>Two</div>
      <div>Three</div>
    </iron-swipeable-pages>

Additionnally, you can specify the following properties regarding the sensitivity of the swipe,
the transition used, and the possibility of cycling. For more details, see below.

It could be a good idea to disable text selection on any of the children that you
want to be swiped:

    .swipe {
      -moz-user-select: none;
      -ms-user-select: none;
      -webkit-user-select: none;
      user-select: none;
      cursor: default;
    }

Note: if you are using "conditional" pages, i.e. some content that are inside `dom-if` template,
it might be useful to use the attribute `force-update` on the element, so that the list of
available swipeable elements will be updated accordingly.

@demo demo/index.html Standard Demo
@demo demo/mobile.html Mobile Demo
@demo demo/conditional.html Conditional Demo
@demo demo/repeat.html Configurable Repeat Demo
@hero hero.svg
-->

<dom-module id="iron-swipeable-pages">
  <style>
    :host {
      position: relative;
      display: block;
    }
    :host > ::content > * {
      position: absolute;
      width: 100%;
      will-change: left, transform;
    }
    /* we cannot use `display=none` to take into account the case of conditional pages */
    :host > ::content > :not(.iron-selected):not(.iron-swiping) {
      width: 0 !important;
      height: 0 !important;
      overflow: hidden;
    }
  </style>

  <template>
    <content id="content"></content>
  </template>

  <script>
    (function() {
      Polymer({
        is: 'iron-swipeable-pages',

        behaviors: [
          Polymer.IronResizableBehavior,
          Polymer.IronSelectableBehavior
        ],

        properties: {
          // as the selected page is the only one visible, activateEvent
          // is both non-sensical and problematic; e.g. in cases where a user
          // handler attempts to change the page and the activateEvent
          // handler immediately changes it back
          activateEvent: {
            type: String,
            readOnly: true,
            value: null
          },

          // if some node are stamped conditionnally via `dom-if`, they should
          // not be selectable to avoid swiping on blank pages.
          // DO NOT CHANGE the default value
          selectable: {
            type: String,
            readOnly: true,
            value: ":not([style*='display']), :not([style*='none'])"
          },

          /**
           * Add extra padding to the offsetWidth while swiping
           * Useful if the element is nested within other elements that enforce a padding
           */
          padding: {
            type: Number,
            value: 0
          },

          /**
           * The value used to decide if a transition is effective and therefore
           * if the page get swiped.
           */
          threshold: {
            type: Number,
            value: 0.3
          },

          /**
           * Prevent cycling between first and last pages by swiping.
           */
          noCycle: {
            type: Boolean,
            value: false
          },

          /**
           * The CSS transition duration applied swiping to next/previous page
           */
          transitionDuration: {
            type: Number,
            value: 250
          },

          /**
           * The maximum global CSS transition duration applied if swiping involves more than one
           * page transition using selection instead of manual swiping.
           */
          maximumTransitionDuration: {
            type: Number,
            value: 0
          },

          /**
           * The CSS transition timing function applied.
           */
          transitionTimingFunction: {
            type: String,
            value: 'cubic-bezier(0.4, 0.0, 0.2, 1)'
          },

          /**
           * This option should be only relevant if you are using conditional pages, i.e.
           * probably using `dom-if` or setting display: 'none' in certain conditions.
           * A call to forceSynchronousItemUpdate is made if any `dom-change` are happening
           */
          forceUpdate: {
            type: Boolean,
            value: false
          },
        },

        listeners: {
          'iron-items-changed': '_onItemsChanged',
          'dom-change': '_onDomChange',
          'iron-deselect': '_onIronDeselectItem',
          'iron-select': '_onIronSelectItem',
          'track': '_onTrack'
        },

        // Element Lifecycle

        ready: function() {
          this.setScrollDirection('y');
          this._animatedPages = [];
        },

        attached: function() {
          document.addEventListener("selectionchange", this._onSelectionChange.bind(this));
        },

        detached: function() {
          document.removeEventListener("selectionchange", this._onSelectionChange.bind(this));
        },

        _onSelectionChange: function(event) {
          var selection = document.getSelection();
          var range = selection ? selection.getRangeAt(0) : undefined;
          if (range && range.startOffset != range.endOffset) {
            this._swipeDisabled = true;
          } else {
            this._swipeDisabled = false;
          }
        },

        // Element page set up

        _onItemsChanged: function(event) {
          var mutations = event.detail;
          for (var i = 0; i < mutations.addedNodes.length; i++) {
            this._addPage(mutations.addedNodes[i]);
          }
          for (var j = 0; j < mutations.removedNodes.length; j++) {
            this._removePage(mutations.removedNodes[j]);
          }
        },

        _addPage: function(page) {
            if (!page || page.nodeType !== Node.ELEMENT_NODE)
              return;
            this.listen(page, 'webkitTransitionEnd', '_onTransitionEnd');
            this.listen(page, 'transitionend', '_onTransitionEnd');
        },

        _removePage: function(page) {
            if (!page || page.nodeType !== Node.ELEMENT_NODE)
              return;
            this.unlisten(page, 'webkitTransitionEnd', '_onTransitionEnd');
            this.unlisten(page, 'transitionend', '_onTransitionEnd');
        },

        _onDomChange: function(event) {
          // something might have change inside a template helper, e.g. `dom-if`
          // so we should call forceSynchronousItemUpdate() to update the item list
          // since it is not performance optimal, this is an opt-in option and we raise a
          // warning if this occurs and the option is not enabled
          if (this.forceUpdate) {
            this.forceSynchronousItemUpdate();
          }
          // TODO: see if we can handle the case where a currently selected element disappear
          // and therefore force a swiping to the next available page...
        },

        // Element tracking
        _onTrack: function(event) {
          var track = event.detail;

          if (this._swipeDisabled || (this.noCycle && !this._canCycle(track))) {
            return;
          }

          if (track.state === 'start' && Math.abs(track.dy) < Math.abs(track.dx)) {
            // if we don't have at least 2 items, no need to swipe...
            if (this.items.length < 2) {
              return;
            }
            this._swipeStarted = true;

            this._trackStart(track);
          } else if (track.state === 'track' && this._swipeStarted) {
            this._trackMove(track);
          } else if (track.state === 'end' && this._swipeStarted) {
            this._trackEnd(track);
          }
        },

        _trackStart: function(trackData) {
          if (this._transitionRunning) {
            // reset pages state
            this._resetPages();
          }
          this._setUpSwipePages();
          this._animatePages(trackData.dx);
          this._switchPageIfNecessary(trackData.dx);
          // Prevent regular touchmove event (disables vertical scroll)
          window.addEventListener('touchmove', this._preventTouchMove);
        },

        _trackMove: function(trackData) {
          this._animatePages(trackData.dx);
          this._switchPageIfNecessary(trackData.dx);
        },

        _trackEnd: function(trackData) {
          if (!this._swipeStarted) {
            return;
          }
          // Activate transition
          for (var i = 0; i < this._animatedPages.length; i++) {
            // TODO PG: be sure it is working on webkit safari
            this._animatedPages[i].style.transition = this._computeTransition(1);
          }
          this._transitionRunning = true;

          // The element is swiped away if the swiping get passed the treshold.
          this._completeSwipe = Math.abs(trackData.dx) > this._getOffsetWidth() * this.threshold;
          if (this._completeSwipe) {
            var direction = trackData.dx > 0;
            // we are swipping, therefore update selected
            direction ? this.selectPrevious() : this.selectNext();
            // trigger the animation in the proper direction
            this._animatePages(direction ? this._getOffsetWidth() : -this._getOffsetWidth());
          } else {
            this._animatePages(0);
          }
          // Enable regular touchmove event (enables vertical scroll again)
          window.removeEventListener('touchmove', this._preventTouchMove);
        },

        _preventTouchMove: function (e) {
          return e && e.preventDefault();
        },

        _onIronDeselectItem: function(event) {
          this._lastIndex = this.indexOf(event.detail.item);
        },

        _onIronSelectItem: function(event) {
          // might happen at init of the component when first selected value is set and ready not called....
          if (this._lastIndex === undefined) {
            return;
          }
          var index = this.indexOf(event.detail.item);

          if (this._completeSwipe) {
            // we just need to reset the flag, the transformation happened already by swiping
            this._completeSwipe = false;
          } else {
            // check if a transition is currently running
            if (this._transitionRunning) {
              // reset pages state and we don't trigger any new animation because lastIndex is not valid anymore
              this._resetPages();
            } else {
              this._swipeStarted = true;
              // reset the animated page list
              this._animatedPages = [];
              // in this case, selected has been modify w/o swiping, we need to apply the transformation
              if (index < this._lastIndex) {
                // we translate to the right
                for (var i = index; i <= this._lastIndex; i++) {
                  this._initPage(this.items[i], this._computeTransition(this._lastIndex-index), this._getOffsetWidth()*(i-this._lastIndex));
                }
              } else {
                // we translate to the left
                for (var j = this._lastIndex; j <= index; j++) {
                  this._initPage(this.items[j], this._computeTransition(index-this._lastIndex), this._getOffsetWidth()*(j-this._lastIndex));
                }
              }
              this._transitionRunning = true;

              // before animating, we need to be sure style are updated correctly
              var lastIndex = this._lastIndex;
              this.async( function() {
                this._animatePages((lastIndex - index) * this._getOffsetWidth());
              });
            }
          }

          // notifyResize
          this.async(function() {
            var selectedPage = this.selectedItem;
            this.resizerShouldNotify = function(element) {
              return element == selectedPage || selectedPage.contains(element);
            };
            this.notifyResize();
          });
        },

        // Element page management
        _setUpSwipePages: function() {
          // reset the animated page list
          this._animatedPages = [];
          // selected page
          this._initPage(this.selectedItem, 'none', 0);
          // left candidate
          var leftIndex = (Number(this.indexOf(this.selectedItem)) - 1 + this.items.length) % this.items.length;
          this._leftCandidate = this.items[leftIndex];
          this._initPage(this._leftCandidate, 'none', -this._getOffsetWidth());
          // right candidate
          var rightIndex = (Number(this.indexOf(this.selectedItem)) + 1) % this.items.length;
          this._rightCandidate = this.items[rightIndex];
          this._initPage(this._rightCandidate, 'none', this._getOffsetWidth());
        },

        // prepare the page for animation and add it to the list of pages to be animated
        _initPage: function(page, transition, left) {
          if (!page) {
            return;
          }
          page.style.left = left + "px";
          // TODO PG: be sure it is working on webkit safari
          page.style.transition = transition;
          this.toggleClass('iron-swiping', true, page);

          this._animatedPages.push(page);
        },

        _animatePages: function(x) {
          for (var i = 0; i < this._animatedPages.length; i++) {
            this.translate3d(x+'px', 0+'px', 0+'px', this._animatedPages[i]);
          }
        },

        // this function is useful if only 2 pages are available and we need to switch the next/previous page
        // on the left/right side depending on the direction of the swipe given with `dx`
        _switchPageIfNecessary: function(dx) {
          if (this._leftCandidate && this._rightCandidate && this._leftCandidate === this._rightCandidate) {
            var direction = dx > 0 ? -1 : 1;
            this._rightCandidate.style.left = (direction * this._getOffsetWidth()) + "px";
          }
        },

        // remove the iron-swiping class and transition
        _resetPages: function() {
          for (var i = 0; i < this._animatedPages.length; i++) {
            this._animatedPages[i].style.transition = 'none';
            this._animatedPages[i].style.left = '0px';
            this.transform('none', this._animatedPages[i]);
            this.toggleClass('iron-swiping', false, this._animatedPages[i]);
          }
          this._transitionRunning = false;
        },

        _onTransitionEnd: function(event) {
          // reset pages state
          this._resetPages();
          this._swipeStarted = false;
        },

        // Element utility functions
        _canCycle: function(trackData) {
          var index = this._valueToIndex(this.selected);

          if (index === 0 && trackData.dx > 0) {
            return false;
          }
          if (index === this.items.length - 1 && trackData.dx < 0) {
            return false;
          }
          return true;
        },

        _getOffsetWidth: function () {
          return this.offsetWidth + (2 * this.padding);
        },

        _computeTransition: function(factor) {
          var duration = factor * this.transitionDuration;
          if (this.maximumTransitionDuration) {
            duration = Math.min(this.maximumTransitionDuration, duration);
          }
          return 'transform ' + duration + 'ms ' + this.transitionTimingFunction;
        }
      });
    }());
  </script>
</dom-module>
